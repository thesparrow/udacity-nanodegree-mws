{"version":3,"sources":["dbhelper.js"],"names":["RESTAURANTS","DBHelper","DATABASE_URL","[object Object]","callback","showCachedMessages","then","fetch","this","response","status","json","data","updateCache","catch","error","id","fetchRestaurants","restaurants","restaurant","find","r","cuisine","results","filter","cuisine_type","neighborhood","neighborhoods","map","v","i","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","imagePath","photograph","imageSuffix","window","innerWidth","marker","L","latlng","lat","lng","title","name","alt","url","urlForRestaurant","addTo","newMap","console","log","getDBPromise","db","store","transaction","objectStore","put","index","openCursor","cursor","advance","deleteRest","delete","continue","navigator","serviceWorker","idb","open","upgradeDB","createObjectStore","keyPath","createIndex","Promise","resolve","getAll","length"],"mappings":"AAAA,MAAMA,YAAc,cAOpB,MAAMC,SAKJC,0BAEE,MAAO,oCAOTC,wBAAwBC,GACtBC,mBAAmBD,GAAUE,KAAK,KAChCC,MAAMC,KAAKN,cACRI,KAAKG,IACoB,MAApBA,EAASC,OAIbD,EACGE,OACAL,KAAKM,IACJC,YAAYD,GACZR,EAAS,KAAMQ,KAEhBE,MAAMC,GAASX,EAASW,EAAO,OAThCX,EAAS,kBAAmB,QAW/BU,MAAMC,GAASX,EAASW,EAAO,SAStCZ,2BAA2Ba,EAAIZ,GAE7BH,SAASgB,iBAAiB,CAACF,EAAOG,KAChC,GAAIH,EACFX,EAASW,EAAO,UACX,CACL,MAAMI,EAAaD,EAAYE,KAAKC,GAAKA,EAAEL,IAAMA,GAC7CG,EAEFf,EAAS,KAAMe,GAGff,EAAS,4BAA6B,SAS9CD,gCAAgCmB,EAASlB,GAEvCH,SAASgB,iBAAiB,CAACF,EAAOG,KAChC,GAAIH,EACFX,EAASW,EAAO,UACX,CAEL,MAAMQ,EAAUL,EAAYM,OAAOH,GAAKA,EAAEI,cAAgBH,GAC1DlB,EAAS,KAAMmB,MAQrBpB,qCAAqCuB,EAActB,GAEjDH,SAASgB,iBAAiB,CAACF,EAAOG,KAChC,GAAIH,EACFX,EAASW,EAAO,UACX,CAEL,MAAMQ,EAAUL,EAAYM,OAAOH,GAAKA,EAAEK,cAAgBA,GAC1DtB,EAAS,KAAMmB,MAQrBpB,+CACEmB,EACAI,EACAtB,GAGAH,SAASgB,iBAAiB,CAACF,EAAOG,KAChC,GAAIH,EACFX,EAASW,EAAO,UACX,CACL,IAAIQ,EAAUL,EACC,OAAXI,IAEFC,EAAUA,EAAQC,OAAOH,GAAKA,EAAEI,cAAgBH,IAE9B,OAAhBI,IAEFH,EAAUA,EAAQC,OAAOH,GAAKA,EAAEK,cAAgBA,IAElDtB,EAAS,KAAMmB,MAQrBpB,0BAA0BC,GAExBH,SAASgB,iBAAiB,CAACF,EAAOG,KAChC,GAAIH,EACFX,EAASW,EAAO,UACX,CAEL,MAAMY,EAAgBT,EAAYU,IAChC,CAACC,EAAGC,IAAMZ,EAAYY,GAAGJ,cAGrBK,EAAsBJ,EAAcH,OACxC,CAACK,EAAGC,IAAMH,EAAcK,QAAQH,IAAMC,GAExC1B,EAAS,KAAM2B,MAQrB5B,qBAAqBC,GAEnBH,SAASgB,iBAAiB,CAACF,EAAOG,KAChC,GAAIH,EACFX,EAASW,EAAO,UACX,CAEL,MAAMkB,EAAWf,EAAYU,IAAI,CAACC,EAAGC,IAAMZ,EAAYY,GAAGL,cAEpDS,EAAiBD,EAAST,OAC9B,CAACK,EAAGC,IAAMG,EAASD,QAAQH,IAAMC,GAEnC1B,EAAS,KAAM8B,MAQrB/B,wBAAwBgB,GACtB,8BAA+BA,EAAWH,KAM5Cb,6BAA6BgB,GAC3B,IACIgB,UADQhB,EAAWiB,WAAajB,EAAWiB,WAAa,YAGxDC,EAAc,OAOlB,OAJIC,SACFD,EAAcC,OAAOC,WAAa,IAAM,OAAS,QAG5CJ,EAAYE,EARA,MAcrBlC,8BAA8BgB,EAAYS,GAExC,MAAMY,EAAS,IAAIC,EAAED,OACnB,CAACrB,EAAWuB,OAAOC,IAAKxB,EAAWuB,OAAOE,KAC1C,CACEC,MAAO1B,EAAW2B,KAClBC,IAAK5B,EAAW2B,KAChBE,IAAK/C,SAASgD,iBAAiB9B,KAInC,OADAqB,EAAOU,MAAMC,QACNX,GASX3B,YAAcK,CAAAA,IACPA,GACHkC,QAAQC,IAAI,sBAGdC,eAAehD,KAAKiD,IAClB,IACIC,EADKD,EAAGE,YAAYzD,YAAa,aACtB0D,YAAY1D,aAC3BkB,EAAYU,IAAIhB,GAAQ4C,EAAMG,IAAI/C,IAGlC4C,EACGI,MAAM,aACNC,WAAW,KAAM,QACjBvD,KAAKwD,IACJ,GAAKA,EACL,OAAOA,EAAOC,QAAQ,MAEvBzD,KAAK,SAAS0D,EAAWF,GACxB,GAAKA,EAIL,OAFAV,QAAQC,IAAI,cAAeS,GAC3BA,EAAOG,SACAH,EAAOI,WAAW5D,KAAK0D,SAKtCV,aAAe,KAERa,UAAUC,eAAmB,cAAe9B,OAK1C+B,IAAIC,KAAK,iBAAkB,EAAGC,IAEvBA,EAAUC,kBAAkBxE,YAAa,CAAEyE,QAAS,OAE1DC,YAAY,YAAa,eARxBC,QAAQC,WAYnBvE,mBAAqBD,CAAAA,GACZkD,eAAehD,KAAKiD,IAKzB,OAJYA,EACTE,YAAYzD,aACZ0D,YAAY1D,aACZ4D,MAAM,aACIiB,SAASvE,KAAKY,IACrBA,GAAeA,EAAY4D,OAAS,GACtC1E,EAAS,KAAMc","file":"dbhelper.js","sourcesContent":["const RESTAURANTS = \"restaurants\";\n/**\n * Common \"database\" helper functions.\n * These functions utilize the sw functionality \n * to cache the images and data on the client-side \n * in order to allow offline work capability. \n */\nclass DBHelper {\n  /**\n   * Database URL call to restaurant API.\n   * TODO: Change this to restaurants.json file location on your server.\n   */\n  static get DATABASE_URL() {\n    const port = 1337; // Change this to your server port\n    return `http://localhost:${port}/restaurants`;\n  }\n\n  /**\n   * GET all restaurants from our API\n   * Response is returned in JSON Format\n   */\n  static fetchRestaurants(callback) {\n    showCachedMessages(callback).then(() => {\n      fetch(this.DATABASE_URL)\n        .then(response => {\n          if (response.status !== 200) {\n            callback(\"API call failed\", null);\n            return;\n          }\n          response\n            .json()\n            .then(data => {\n              updateCache(data);\n              callback(null, data);\n            })\n            .catch(error => callback(error, null));\n        })\n        .catch(error => callback(error, null));\n    });\n  }\n\n  /**\n   * GET a restaurant by its ID.\n   * Find restaurant based on id. \n   * Error handeling. \n   */\n  static fetchRestaurantById(id, callback) {\n    // fetch all restaurants with proper error handling.\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        const restaurant = restaurants.find(r => r.id == id);\n        if (restaurant) {\n          // Got the restaurant\n          callback(null, restaurant);\n        } else {\n          // Restaurant does not exist in the database\n          callback(\"Restaurant does not exist\", null);\n        }\n      }\n    });\n  }\n\n  /**\n   * GET restaurants by a cuisine type with proper error handling.\n   */\n  static fetchRestaurantByCuisine(cuisine, callback) {\n    // Fetch all restaurants  with proper error handling\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given cuisine type\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * GET restaurants by a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Filter restaurants to have only given neighborhood\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * GET restaurants by a cuisine and a neighborhood with proper error handling.\n   */\n  static fetchRestaurantByCuisineAndNeighborhood(\n    cuisine,\n    neighborhood,\n    callback\n  ) {\n    // GET all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        let results = restaurants;\n        if (cuisine != \"all\") {\n          // filter by cuisine\n          results = results.filter(r => r.cuisine_type == cuisine);\n        }\n        if (neighborhood != \"all\") {\n          // filter by neighborhood\n          results = results.filter(r => r.neighborhood == neighborhood);\n        }\n        callback(null, results);\n      }\n    });\n  }\n\n  /**\n   * GET all neighborhoods with proper error handling.\n   */\n  static fetchNeighborhoods(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all neighborhoods from all restaurants\n        const neighborhoods = restaurants.map(\n          (v, i) => restaurants[i].neighborhood\n        );\n        // Remove duplicates\n        const uniqueNeighborhoods = neighborhoods.filter(\n          (v, i) => neighborhoods.indexOf(v) == i\n        );\n        callback(null, uniqueNeighborhoods);\n      }\n    });\n  }\n\n  /**\n   * GET all cuisines with proper error handling.\n   */\n  static fetchCuisines(callback) {\n    // Fetch all restaurants\n    DBHelper.fetchRestaurants((error, restaurants) => {\n      if (error) {\n        callback(error, null);\n      } else {\n        // Get all cuisines from all restaurants\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type);\n        // Remove duplicates from cuisines\n        const uniqueCuisines = cuisines.filter(\n          (v, i) => cuisines.indexOf(v) == i\n        );\n        callback(null, uniqueCuisines);\n      }\n    });\n  }\n\n  /**\n   * Generate UNIQUE Restaurant page URL.\n   */\n  static urlForRestaurant(restaurant) {\n    return `./restaurant.html?id=${restaurant.id}`;\n  }\n\n  /**\n   * Generate restaurant image URL.\n   */\n  static imageUrlForRestaurant(restaurant) {\n    let image = restaurant.photograph ? restaurant.photograph : \"default\";\n    let imagePath = `/img/${image}`;\n    let imgExtension = \"jpg\";\n    let imageSuffix = \"_2x.\";\n\n    //fetch 1x images for lower resolution devices\n    if (window) {\n      imageSuffix = window.innerWidth < 500 ? \"_1x.\" : \"_2x.\";\n    }\n\n    return imagePath + imageSuffix + imgExtension;\n  }\n\n  /**\n   * Map marker for a restaurant.\n   */\n  static mapMarkerForRestaurant(restaurant, map) {\n    // https://leafletjs.com/reference-1.3.0.html#marker\n    const marker = new L.marker(\n      [restaurant.latlng.lat, restaurant.latlng.lng],\n      {\n        title: restaurant.name,\n        alt: restaurant.name,\n        url: DBHelper.urlForRestaurant(restaurant)\n      }\n    );\n    marker.addTo(newMap);\n    return marker;\n  }\n}\n\n/* Index Db start */\n\n// Use IndexedDB to store restuarants in the client's browser\n// ref: https://developers.google.com/web/ilt/pwa/working-with-indexeddb\n\nupdateCache = restaurants => {\n  if (!restaurants) {\n    console.log(\"No data to update!\");\n  }\n\n  getDBPromise().then(db => {\n    let tx = db.transaction(RESTAURANTS, \"readwrite\");\n    let store = tx.objectStore(RESTAURANTS);\n    restaurants.map(data => store.put(data));\n\n    //Delete restaurant data\n    store\n      .index(\"updatedAt\")\n      .openCursor(null, \"prev\")\n      .then(cursor => {\n        if (!cursor) return;\n        return cursor.advance(30);\n      })\n      .then(function deleteRest(cursor) {\n        if (!cursor) return;\n\n        console.log(\"Delete data\", cursor);\n        cursor.delete();\n        return cursor.continue().then(deleteRest);\n      });\n  });\n};\n\ngetDBPromise = () => {\n  //Making sure serviceWorker or IndexedDB is supported by the browser\n  if (!navigator.serviceWorker || !(\"indexedDB\" in window)) {\n    return Promise.resolve();\n  }\n\n  //open our IndexDB\n  return idb.open(\"restaurants-db\", 5, upgradeDB => {\n    // Create an objectStore for this database\n    let store = upgradeDB.createObjectStore(RESTAURANTS, { keyPath: \"id\" });\n    // Create an index \n    store.createIndex(\"updatedAt\", \"updatedAt\");\n  });\n};\n\nshowCachedMessages = callback => {\n  return getDBPromise().then(db => {\n    let index = db\n      .transaction(RESTAURANTS)\n      .objectStore(RESTAURANTS)\n      .index(\"updatedAt\");\n    return index.getAll().then(restaurants => {\n      if (restaurants && restaurants.length > 0) {\n        callback(null, restaurants);\n      }\n    });\n  });\n};\n\n/* Index Db end */\n"]}